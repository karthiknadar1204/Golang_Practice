# Basic Syntax

``` go
package main

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}
```

to execute first run 
`go build path/to/the/file`

then run the executable file
`./path/to/the/file`

eg:
-> go build main.go
-> ./main

we could also directly run without the build command using 
`go run path/to/the/file`

eg:
-> go run main.go







# Loops
Golang has only one loop construct, the for loop.

``` go
package main

import "fmt"

func main() {
	for i := 0; i < 5; i++ {
		fmt.Println(i)
	}
}
```










## Break and Continue

Go provides two important keywords for controlling loop execution:

### break
The `break` statement terminates the loop immediately and continues execution at the next statement after the loop.

### continue
The `continue` statement skips the rest of the current iteration and moves to the next iteration of the loop.

Here's an example demonstrating both:


``` go
package main

import "fmt"

func main() {
// Break example
	fmt.Println("Break example:")
	for i := 0; i < 10; i++ {
		if i == 5 {
			break // exits the loop when i equals 5
		}
		fmt.Println(i)
	}

// Continue example
	fmt.Println("\nContinue example:")
	for i := 0; i < 5; i++ {
		if i == 2 {
			continue // skips printing when i equals 2
		}
		fmt.Println(i)
	}
}
```









# Conditionals
if statements in Go do not use parentheses around the condition:

``` go
package main

import "fmt"	

func main() {
	if height > 4 {
		fmt.Println("You are tall enough!")
	}
}
```

``` go
package main

import "fmt"

func main() {
	if height > 6 {
		fmt.Println("You are super tall!")
	} else if height > 4 {
		fmt.Println("You are tall enough!")
	} else {
		fmt.Println("You are not tall enough!")
	}
}
```


## Multiple Conditions
In Go, you can combine multiple conditions using logical operators:
- `&&` (AND)
- `||` (OR)
- `!` (NOT)

Here's an example:


``` go
package main

import "fmt"

func main() {
	age := 25
	height := 5.8

	// Using AND (&&)
	if age > 18 && height > 5.0 {
		fmt.Println("You are an adult and tall enough!")
	}

	// Using OR (||)
	if age < 18 || height < 5.0 {
		fmt.Println("You are either young or short!")
	}

	// Combining multiple conditions
	if (age > 18 && height > 5.0) || age > 60 {
		fmt.Println("You can enter the ride!")
	}
}
```




## Variable Declaration in Conditionals

In Go, you can declare and initialize variables directly in the if statement.
This is called an "initialization statement" and is a common pattern. The variable declared 
in the initialization statement is only available within the scope of the if statement.

Here's an example:

``` go
package main

import "fmt"

func main() {
	if age := 25; age > 18 {
		fmt.Println("You are an adult!")
	}
}
```


Key points:
- Variables declared in the initialization statement are only available within the if block
- You can declare multiple variables using this syntax
- The initialization is separated from the condition by a semicolon
- This pattern helps keep variables scoped to where they're needed

This is particularly useful when working with functions that return multiple values:



``` go
package main

import (
	"fmt"
	"os"
)

func main() {
	if file, err := os.Open("file.txt"); err == nil {
		// do something with the file
		defer file.Close()
	} else {
		fmt.Println("Error opening file:", err)
	}
	// file and err are not accessible here
}
```

### Go does not support the ternary operator.










# Switch Statements

Switch statements in Go are versatile and can be used in several ways.
They're cleaner than long if-else chains.
unlike other languages, Go switch statements do not fall through by default i.e we do not need to use break statement.

## Basic Switch

``` go
package main

import "fmt"

func main() {
	score := 85
	switch {
	case score >= 90:
		fmt.Println("Grade: A")
	case score >= 80:
		fmt.Println("Grade: B")
	case score >= 70:
		fmt.Println("Grade: C")
	default:
		fmt.Println("Grade: F")
	}
}
```



## Switch without Expression


``` go
package main

import "fmt"

func main() {
	score := 85
	switch {
	case score >= 90:
		fmt.Println("Grade: A")
	case score >= 80:
		fmt.Println("Grade: B")
	case score >= 70:
		fmt.Println("Grade: C")
	default:
		fmt.Println("Grade: F")
	}
}
```



## Switch with Initialization Statement

``` go
package main

import "time"
import "fmt"

func main() {
	switch today := time.Now().Weekday(); today {
	case time.Saturday:
		fmt.Println("It's Saturday!")
	case time.Sunday:
		fmt.Println("It's Sunday!")
	default:
		fmt.Printf("Looking forward to the weekend! Today is %v\n", today)
	}
}
```



## Fallthrough

By default, Go switch statements break automatically after a case matches. 
Use `fallthrough` to execute the next case regardless of its condition:


``` go
package main

import "fmt"

func main() {
	num := 75
	switch {
	case num > 50:
		fmt.Println("Number is greater than 50")
		fallthrough
	case num > 60:
		fmt.Println("Number is greater than 60")
		fallthrough
	case num > 70:
		fmt.Println("Number is greater than 70")
	case num > 80:
		fmt.Println("Number is greater than 80")
	}
}
```



## Type Switch

Go also supports type switches to check the type of an interface:

``` go
package main

import "fmt"

func checkType(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Integer: %v\n", v)
	case string:
		fmt.Printf("String: %v\n", v)
	case bool:
		fmt.Printf("Boolean: %v\n", v)
	default:
		fmt.Printf("Unknown type\n")
	}
}

func main() {
	checkType(42) // Integer: 42
	checkType("Hello") // String: Hello
	checkType(true) // Boolean: true
	checkType(3.14) // Unknown type
}
```



Key points about Go switch statements:
- Cases don't need a break statement (automatic break)
- Cases can be expressions
- Multiple values can be tested in a single case
- Type switches help work with interfaces
- `fallthrough` forces execution to continue to the next case
- The default case handles all unmatched values



